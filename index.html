<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>⚡ Smart Rephraser Pro</title>
  <style>
    :root {
      --primary: #4a6bff;
      --primary-hover: #3a56e0;
      --background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      --card-bg: rgba(255, 255, 255, 0.98);
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--background);
      color: #333;
      padding: 2rem;
      min-height: 100vh;
    }

    h2 {
      text-align: center;
      font-size: 2.5rem;
      background: linear-gradient(90deg, #4a6bff, #00c6ff);
      -webkit-background-clip: text;
      color: transparent;
    }

    .container {
      max-width: 900px;
      margin: auto;
    }

    .editable-input, .output {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
      min-height: 200px;
      margin-bottom: 1.5rem;
      overflow-y: auto;
    }

    .editable-input {
      border: 2px dashed #ccc;
    }

    .editable-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 1rem;
    }

    button {
      flex: 1;
      padding: 1rem;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s ease;
    }

    button:hover {
      background: var(--primary-hover);
    }

    .output h1, .output h2, .output h3 {
      font-weight: 800;
    }

    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>⚡ Smart Rephraser Pro</h2>

    <div class="editable-input" contenteditable="true" id="inputEditor" placeholder="Paste your content here with headings..."></div>

    <div class="controls">
      <button onclick="rephraseContent()">Rephrase</button>
      <button onclick="copyOutput()">Copy Output</button>
    </div>

    <div class="output" id="outputEditor"></div>
  </div>

  <script>
  // Global variables
  const synonymCache = {};
  const stopWords = new Set(["the", "and", "is", "are", "in", "on", "at", "a", "to", "of", "for", "with", "that", "this"]);
  const MAX_CHUNK_SIZE = 300; // Optimal balance between performance and responsiveness

  // DOM elements
  const inputText = document.getElementById("inputText");
  const outputText = document.getElementById("outputText");
  const rephraseBtn = document.getElementById("rephraseBtn");
  const copyBtn = document.getElementById("copyBtn");
  const progressBar = document.getElementById("progress");
  const progressContainer = document.getElementById("progressContainer");
  const wordCountDisplay = document.getElementById("wordCount");

  // Initialize
  inputText.addEventListener("input", updateWordCount);
  updateWordCount();

  // Word counter
  function updateWordCount() {
    const text = inputText.value.trim();
    const count = text ? text.split(/\s+/).length : 0;
    wordCountDisplay.textContent = count;
  }

  // Check if the word is a proper noun, acronym, or number
  function isSpecialWord(word) {
    // Checks if the word is a number or contains digits
    if (/\d/.test(word)) return true;
    
    // Checks if it's an acronym or proper noun (capitalized word in the middle of text)
    return /^[A-Z][a-zA-Z]*$/.test(word) || /^[A-Z]{2,}$/.test(word);
  }

  // Main rephrasing function
  async function rephraseText() {
    const text = inputText.value.trim();
    if (!text) return alert('Please enter some text to rephrase!');

    // UI Setup
    rephraseBtn.classList.add("loading");
    rephraseBtn.disabled = true;
    copyBtn.disabled = true;
    progressContainer.style.display = "block";
    outputSection.classList.remove("visible");

    try {
      // Process in chunks for better performance
      const chunks = splitIntoChunks(text, MAX_CHUNK_SIZE);
      let result = [];
      
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const processed = await processChunk(chunk);
        result.push(processed);
        
        // Update progress
        const progress = ((i + 1) / chunks.length) * 100;
        progressBar.style.width = `${progress}%`;
        
        // Partial output update for better UX
        if (i % 3 === 0 || i === chunks.length - 1) {
          outputText.textContent = result.join(" ") + (i < chunks.length - 1 ? "..." : "");
          outputSection.classList.add("visible");
          scrollToOutput();
        }
      }
      
      outputText.textContent = result.join(" ");
      outputSection.classList.add("visible");
    } catch (error) {
      console.error("Rephrasing error:", error);
      alert("An error occurred during rephrasing. Please try again.");
    } finally {
      rephraseBtn.classList.remove("loading");
      rephraseBtn.disabled = false;
      copyBtn.disabled = false;
    }
  }

  // Process a single chunk of text
  async function processChunk(text) {
    // First get all candidate words for replacement
    const words = text.split(/(\w+|\W+)/).filter(Boolean);
    const wordsToReplace = words.filter(word => {
      const cleanWord = word.replace(/\W/g, '');
      return cleanWord.length > 3 && !stopWords.has(cleanWord.toLowerCase()) && !isSpecialWord(word);
    });

    // Batch fetch synonyms
    await fetchSynonymsBatch(wordsToReplace);

    // Process each word with cached synonyms
    return words.map(word => {
      const cleanWord = word.replace(/\W/g, '');
      if (cleanWord.length > 3 && !stopWords.has(cleanWord.toLowerCase()) && !isSpecialWord(word)) {
        const synonym = synonymCache[cleanWord.toLowerCase()] || word;
        // Preserve original capitalization
        return /^[A-Z]/.test(word) ? 
          synonym.charAt(0).toUpperCase() + synonym.slice(1) : 
          synonym;
      }
      return word;
    }).join(' ');
  }

  // Batch fetch synonyms from API
  async function fetchSynonymsBatch(words) {
    const uniqueWords = [...new Set(words
      .map(word => word.toLowerCase())
      .filter(word => !synonymCache[word] && word.length > 3)
    )];

    if (uniqueWords.length === 0) return;

    try {
      // Batch API call (note: Datamuse doesn't support true batching, this is a mock)
      // In a production app, you'd use a backend service with proper batching
      const results = await Promise.all(
        uniqueWords.map(word => 
          fetch(`https://api.datamuse.com/words?rel_syn=${word}&max=1`)
            .then(res => res.json())
            .then(data => ({ word, synonym: data[0]?.word || null }))
            .catch(() => ({ word, synonym: null }))
        )
      );

      // Cache results
      results.forEach(({ word, synonym }) => {
        if (synonym) synonymCache[word] = synonym;
      });
    } catch (error) {
      console.error("Batch synonym error:", error);
    }
  }

  // Helper function to split text into chunks
  function splitIntoChunks(text, chunkSize) {
    const words = text.split(/\s+/);
    const chunks = [];
    
    for (let i = 0; i < words.length; i += chunkSize) {
      chunks.push(words.slice(i, i + chunkSize).join(' '));
    }
    
    return chunks;
  }

  // UI Helpers
  function scrollToOutput() {
    outputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  function copyToClipboard() {
    const text = outputText.textContent;
    if (!text || text.includes("Your rephrased text")) {
      alert("Nothing to copy!");
      return;
    }
    
    navigator.clipboard.writeText(text)
      .then(() => {
        copyBtn.textContent = "Copied!";
        setTimeout(() => copyBtn.textContent = "Copy Result", 2000);
      })
      .catch(err => {
        console.error("Copy failed:", err);
        alert("Failed to copy text");
      });
  }

  // Auto-expand textarea
  inputText.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = this.scrollHeight + 'px';
  });
</script>

</body>
</html>
